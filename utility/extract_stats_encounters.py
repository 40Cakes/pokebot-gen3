import argparse
import json
import re
import sys
from datetime import datetime
from rich.progress import Progress
from pathlib import Path
from typing import Never
from zipfile import ZipFile, ZIP_DEFLATED

sys.path.append(str(Path(__file__).parent.parent))

from modules.console import console
from modules.files import make_string_safe_for_file_name
from modules.game import set_rom
from modules.map_data import MapRSE, MapFRLG
from modules.modes import get_bot_mode_names
from modules.profiles import load_profile_by_name
from modules.runtime import get_base_path
from modules.stats import StatsDatabase
from modules.version import pokebot_name, pokebot_version


def fail(error_message: str, exit_code: int = 1, extra_content: str | None = None) -> Never:
    console.file = console.stderr
    console.print(f"[white on red]{error_message}[/]")
    if extra_content is not None:
        console.line()
        console.print(extra_content)
    sys.exit(exit_code)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=f"{pokebot_name} {pokebot_version} Stats Exporter")
    parser.add_argument(
        "--format",
        action="store",
        dest="format",
        choices={"json", "jsonlines", "pk3"},
        default="json",
        help="Specify the export format.",
    )
    parser.add_argument(
        "--from",
        action="store",
        dest="from_date",
        help="Only export encounters after this. Either an ISO 8601 date string (e.g. `2025-03-01T12:34:56`) or an encounter ID.",
    )
    parser.add_argument(
        "--to",
        action="store",
        dest="to_date",
        help="Only export encounters before this. Either an ISO 8601 date string (e.g. `2025-03-01T12:34:56`) or an encounter ID.",
    )
    parser.add_argument(
        "--map",
        action="append",
        dest="map",
        help="Only export encounters from a particular map. This can be the (internal) name of the map, or a `group:map` notation used by the game. This can be used multiple times.",
    )
    parser.add_argument(
        "--bot-mode",
        action="append",
        dest="bot_mode",
        help="Only export encounters generated by a particular bot mode. This can be used multiple times. (In order to specify a bot mode containing spaces, either wrap it in quotes or simply omit the spaces.)",
    )
    parser.add_argument(
        "--outcome",
        action="append",
        dest="outcome",
        choices={
            "Won",
            "Lost",
            "Draw",
            "RanAway",
            "PlayerTeleported",
            "OpponentFled",
            "Caught",
            "NoSafariBallsLeft",
            "OpponentTeleported",
        },
        help="Only export encounters with a particular outcome. This can be used multiple times.",
    )
    parser.add_argument(
        "--filter",
        action="store",
        dest="filter",
        choices={"shiny", "custom_catch_filter", "roamer", "of_interest", "all"},
        default="of_interest",
        help="Only export encounters that match a particular type. The default (`of_interest`) will filter all shinies, roamers, and custom catch filter matches.",
    )
    parser.add_argument(
        action="store",
        dest="profile",
        help="Name of the profile from which to extract the stats. This profile must have had at least one encounter.",
    )
    args = parser.parse_args()

    profile_directory = get_base_path() / "profiles" / args.profile
    if not profile_directory.exists() or not profile_directory.is_dir():
        fail(f"Profile `{args.profile}` does not exist.")

    stats_file = profile_directory / "stats.db"
    if not stats_file.exists() or not stats_file.is_file():
        fail(
            f"Profile `{args.profile}` does not contain a `stats.db` file. Maybe it hasn't experienced any encounters yet? Or maybe it's a very old profile that has not been converted to the new format? (Just try running the profile and generating one encounter.)",
        )

    profile = load_profile_by_name(args.profile)
    set_rom(profile.rom)

    where_clause = []
    where_parameters = []

    if args.map is not None:
        map_where_clause = []
        if profile.rom.is_rse:
            map_enum = MapRSE
        else:
            map_enum = MapFRLG

        for map_name in args.map:
            if re.match(r"^\d+:\d+$", map_name):
                map_group, map_number = map_name.split(":")
                map_group_and_number = int(map_group), int(map_number)
                if map_group_and_number not in map_enum:
                    fail(f"Map `{map_name}` could not be found.")
                else:
                    map_where_clause.append("map = ?")
                    where_parameters.append(map_enum(map_group_and_number).name)
            else:
                key = map_name.upper()
                if not hasattr(map_enum, key):
                    fail(f"Map `{map_name}` could not be found.")
                else:
                    map_where_clause.append("map = ?")
                    where_parameters.append(key)

        if len(map_where_clause) > 0:
            where_clause.append(f"({' OR '.join(map_where_clause)})")

    def normalise_bot_mode_name(name: str) -> str:
        return name.replace(" ", "").replace("(", "").replace(")", "").replace("-", "").lower()

    available_bot_modes = dict()
    for bot_mode_name in get_bot_mode_names():
        key = normalise_bot_mode_name(bot_mode_name)
        available_bot_modes[key] = bot_mode_name

    if args.bot_mode is not None:
        bot_mode_where_clause = []

        for bot_mode in args.bot_mode:
            key = normalise_bot_mode_name(bot_mode)
            if key not in available_bot_modes:
                fail(
                    f"Bot mode `{bot_mode}` does not exist.",
                    extra_content=f"Available bot modes are:\n\n{'\n'.join([f' * {bot_mode}' for bot_mode in get_bot_mode_names()])}",
                )
            else:
                bot_mode_where_clause.append(f"bot_mode = ?")
                where_parameters.append(available_bot_modes[key])

        if len(bot_mode_where_clause) > 0:
            where_clause.append(f"({' OR '.join(bot_mode_where_clause)})")

    if args.outcome is not None:
        outcome_where_clause = []
        for outcome in args.outcome:
            outcome_where_clause.append(f"outcome = ?")
            where_parameters.append(outcome)
        if len(outcome_where_clause) > 0:
            where_clause.append(f"({' OR '.join(outcome_where_clause)})")

    if args.from_date is not None:
        if re.match(r"^[1-9]\d+$", args.from_date):
            where_clause.append("encounter_id >= ?")
            where_parameters.append(int(args.from_date))
        elif re.match(r"^\d{4}-?\d{2}-?\d{2}(T\d{2}[-:]?\d{2}[:-]?\d{2})?$", args.from_date):
            from_date = datetime.fromisoformat(args.from_date)
            where_clause.append("encounter_time >= ?")
            where_parameters.append(from_date.isoformat())
        else:
            fail(f"`from` value is neither an encounter ID nor a valid date format: `{args.from_date}`.")

    if args.to_date is not None:
        if re.match(r"^[1-9]\d+$", args.to_date):
            where_clause.append("encounter_id <= ?")
            where_parameters.append(int(args.to_date))
        elif re.match(r"^\d{4}-?\d{2}-?\d{2}(T\d{2}[-:]?\d{2}[:-]?\d{2})?1$", args.to_date):
            to_date = datetime.fromisoformat(args.to_date)
            where_clause.append("encounter_time <= ?")
            where_parameters.append(to_date.isoformat())
        else:
            fail(f"`to` value is neither an encounter ID nor a valid date format: `{args.to_date}`.")

    if args.filter == "shiny":
        where_clause.append("is_shiny = 1")
    elif args.filter == "roamer":
        where_clause.append("is_roamer = 1")
    elif args.filter == "custom_catch_filters":
        where_clause.append("matching_custom_catch_filters IS NOT NULL")
        where_clause.append("matching_custom_catch_filters != ''")
    elif args.filter == "of_interest":
        where_clause.append(
            "is_shiny = 1 OR is_roamer = 1 OR (matching_custom_catch_filters IS NOT NULL AND matching_custom_catch_filters != '')"
        )

    stats_db = StatsDatabase(profile)

    if len(where_clause) == 0:
        where_clause = None
    else:
        where_clause = " AND ".join(where_clause)

    amount = stats_db.count_encounters(where_clause, where_parameters)
    result = stats_db.query_encounters(where_clause, where_parameters, limit=None)

    if args.format == "json":
        print("[", end="")
        is_first = True
        for encounter in result:
            if is_first:
                is_first = False
            else:
                print(",", end="")
            print(json.dumps(encounter.to_dict()), end="")
        print("]")

    elif args.format == "jsonlines":
        for encounter in result:
            print(json.dumps(encounter.to_dict()))

    elif args.format == "pk3":
        export_file = profile_directory / f"stats_export_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.zip"
        existing_file_names = set()
        with Progress() as progress:
            progress_task = progress.add_task("Writing PK3s to ZIP file...", total=amount)
            with ZipFile(export_file, "w", compression=ZIP_DEFLATED) as zip:
                for encounter in result:
                    file_name = f"{encounter.pokemon.species.national_dex_number}"
                    if encounter.is_shiny:
                        file_name += " â˜…"

                    file_name = (
                        f"{file_name} - {make_string_safe_for_file_name(encounter.pokemon.species_name_for_stats)} - {encounter.pokemon.nature} "
                        f"[{encounter.pokemon.ivs.sum()}] - {hex(encounter.pokemon.personality_value)[2:].upper()}.pk3"
                    )

                    if file_name not in existing_file_names:
                        zip.writestr(file_name, encounter.pokemon.data)
                        existing_file_names.add(file_name)

                    progress.update(progress_task, advance=1)
        console.print(f"[green]Export written to [bold]{export_file}[/bold][/green]")
