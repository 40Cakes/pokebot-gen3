from enum import Enum, auto

from modules.battle_state import BattleState
from modules.items import Item
from modules.pokemon import Pokemon, Move


class BattleStrategy:
    def party_can_battle(self) -> bool:
        """
        Decides whether the party is in good enough shape to battle, or whether it needs healing.
        :return: True if the party is in a battle-worthy shape or False if it should be healed as
                 soon as possible,
        """
        raise NotImplementedError

    def pokemon_can_battle(self, pokemon: Pokemon) -> bool:
        """
        Decides whether a given Pokemon is capable and in good enough shape to
        fight the current opponent.
        :param pokemon: The Pokemon to check.
        :return: True if the Pokemon is a good match
        """
        raise NotImplementedError

    def which_move_should_be_replaced(self, pokemon: Pokemon, new_move: Move) -> int:
        """
        Decides whether a new move should be learned or not.
        :param pokemon: The Pokemon that is about to learn the move.
        :param new_move: The move that is about to be learned.
        :return: The index of the move that should be replaced (0-3) or 4 if the new move should not be learned.
        """
        raise NotImplementedError

    def should_allow_evolution(self, pokemon: Pokemon, party_index: int) -> bool:
        """
        This is called during the evolution scene after a battle and decides whether
        the evolution should be permitted to happen or whether it should be cancelled.
        :param pokemon: The Pokémon that is about to evolve.
        :param party_index: That Pokémon's party index.
        :return: True if the evolution should happen, False if it should be cancelled.
        """
        raise NotImplementedError

    def should_flee_after_faint(self, battle_state: BattleState) -> bool:
        """
        This is called during wild encounters after the lead Pokemon has fainted, to decide
        whether to switch in a new lead or whether to attempt to run away.
        :param battle_state: Data structure about the current state of the battle.
        :return: True if we should try to run away, False otherwise.
        """
        raise NotImplementedError

    def choose_new_lead_after_battle(self) -> int | None:
        """
        Is called after a battle to decide whether the lead should be rotated (for example because
        it is too weak.)
        :return: The party index of the Pokemon that should be rotated to the top of the party, or None if not change
                 is required.
        """
        raise NotImplementedError

    def choose_new_lead_after_faint(self, battle_state: BattleState) -> int:
        """
        Decides which new Pokemon to switch in after the current lead has fainted.
        :param battle_state: Data structure about the current state of the battle.
        :return: The party index of the Pokemon that should be switched in.
        """
        raise NotImplementedError

    def decide_turn(self, battle_state: BattleState) -> tuple["TurnAction", any]:
        """
        This is called at the start of every turn and should return a decision on what action to take.
        :param battle_state: Data structure about the current state of the battle.
        :return: The action that should be taken. Use `TurnAction.use_move()`, `TurnAction.rotate_lead()`,
                 `TurnAction.use_item()` or `TurnAction.run_away()` to generate the return value.
        """
        raise NotImplementedError

    def decide_turn_in_double_battle(self, battle_state: BattleState, battler_index: int) -> tuple["TurnAction", any]:
        """
        This is similar to `decide_turn()`, except that it is called in double battles -- once for each
        Pokémon currently on the field.
        :param battle_state: Data structure about the current state of the battle.
        :param battler_index: 0 (left Pokémon) or 1 (right Pokémon), depending on which Pokémon the move
                              should be chosen for.
        :return: The action that should be taken. Same as for `decide_turn()`, except that the target for
                 a move can be specified by using `TurnAction.use_move_against_left_side_opponent()` or
                 `TurnAction.use_move_against_left_side_opponent()`.
        """
        raise NotImplementedError

    def decide_turn_in_safari_zone(self, battle_state: BattleState) -> tuple["SafariTurnAction", any]:
        """
        This is similar to `decide_turn()`, except that it will be called for Safari Zone battles.
        :param battle_state: Data structure about the current state of the battle.
        :return: The action that should be taken. Should be generated by using
                 `SafariTurnAction.throw_ball()`, `SafariTurnAction.poke_block()`,
                 `SafariTurnAction.go_near()`, or `SafariTurnAction.run_away()`.
        """
        raise NotImplementedError


class TurnAction(Enum):
    UseMove = auto()
    UseMoveAgainstRightSideOpponent = auto()
    UseMoveAgainstPartner = auto()
    RotateLead = auto()
    UseItem = auto()
    RunAway = auto()
    SwitchToManual = auto()

    @staticmethod
    def use_move(move_index: int) -> tuple["TurnAction", int]:
        return TurnAction.UseMove, move_index

    @staticmethod
    def use_move_against_left_side_opponent(move_index: int) -> tuple["TurnAction", int]:
        return TurnAction.use_move(move_index)

    @staticmethod
    def use_move_against_right_side_opponent(move_index: int) -> tuple["TurnAction", int]:
        return TurnAction.UseMoveAgainstRightSideOpponent, move_index

    @staticmethod
    def use_move_against_partner(move_index: int) -> tuple["TurnAction", int]:
        return TurnAction.UseMoveAgainstPartner, move_index

    @staticmethod
    def rotate_lead(new_lead_index: int) -> tuple["TurnAction", int]:
        return TurnAction.RotateLead, new_lead_index

    @staticmethod
    def use_item(item_to_use: Item) -> tuple["TurnAction", Item]:
        return TurnAction.UseItem, item_to_use

    @staticmethod
    def use_item_on(item_to_use: Item, party_index: int) -> tuple["TurnAction", tuple[Item, int]]:
        return TurnAction.UseItem, (item_to_use, party_index)

    @staticmethod
    def run_away() -> tuple["TurnAction", None]:
        return TurnAction.RunAway, None

    @staticmethod
    def switch_to_manual() -> tuple["TurnAction", None]:
        return TurnAction.SwitchToManual, None


class SafariTurnAction(Enum):
    ThrowBall = auto()
    Pokeblock = auto()
    GoNear = auto()
    Bait = auto()
    Rock = auto()
    RunAway = auto()
    SwitchToManual = auto()

    @staticmethod
    def throw_ball() -> tuple["SafariTurnAction", None]:
        return SafariTurnAction.ThrowBall, None

    @staticmethod
    def pokeblock(block_index: int) -> tuple["SafariTurnAction", int]:
        return SafariTurnAction.Pokeblock, block_index

    @staticmethod
    def go_near() -> tuple["SafariTurnAction", None]:
        return SafariTurnAction.GoNear, None

    @staticmethod
    def bait() -> tuple["SafariTurnAction", None]:
        return SafariTurnAction.Bait, None

    @staticmethod
    def rock() -> tuple["SafariTurnAction", None]:
        return SafariTurnAction.Rock, None

    @staticmethod
    def run_away() -> tuple["SafariTurnAction", None]:
        return SafariTurnAction.RunAway, None

    @staticmethod
    def switch_to_manual() -> tuple["SafariTurnAction", None]:
        return SafariTurnAction.SwitchToManual, None
